function [J, A, x, b, J_cost_combined] = ioc_cost_func(z_init, J_cost_all, J_const_all, c_const, param)
% IOC cost function calc. combine the matrices generated by setup_ioc into
% the form that the pivot requires
[lambda_use, c_use] = vec2mat_extra(z_init, param.dof_count, param.c_array_len);

J_cost_combined = horzcat(J_cost_all{:}); 
J_const_combined = horzcat(J_const_all{:}); 

% calculate the cost function side of the eq'n
J_b = J_cost_all{param.pivotTerm}; % pull out the pivot term
J_cost_all{param.pivotTerm} = []; % the nth term is the pivot, don't include it (ie J_coeff_ddq)
A_cost = horzcat(J_cost_all{:}); 

% calculate the const function side fo the eq'n
% J_coeff_constBlk = blkdiag(J_coeff_const{:}); 
% A = blkdiag(A_cost, zeros(size(J_coeff_constBlk))); % include the constraints base
% b = [J_b; zeros(size(J_coeff_constBlk, 1), 1)];

A = A_cost; % do not include the constraints
b = J_b;

% combine the two sides
len_constx = length(param.const_x);
len_constdx = length(param.const_dx);
len_constddx = length(param.const_ddx);
x = [c_use];

for ind_const = 1:length(J_const_all)
    J_cost_posture_nonzerosInd = find(J_const_all{ind_const});
    A_upperDiag = diag(J_const_all{ind_const});
    A_upperShrink = A_upperDiag(:, J_cost_posture_nonzerosInd);
%     A(1:length(J_const_all{ind_const}), (size(A_cost, 2)+1):(size(A_cost, 2)+length(J_cost_posture_nonzerosInd))) = A_upperShrink;
    A = [A A_upperShrink];

    % multiply the constraint by the constraint coeffs and assemble that
    % component of the x array
    switch ind_const
        case 1
            % q
            for ind_constx = 1:length(param.const_x)
                x = [x; c_const(ind_const)*lambda_use(:, ind_constx)];
            end
            
        case 2
            % dq
            for ind_constx = 1:length(param.const_dx)
                x = [x; c_const(ind_const)*lambda_use(:, len_constx+ind_constx)];
            end
            
        case 3
            % ddq
            for ind_constx = 1:length(param.const_ddx)
                x = [x; c_const(ind_const)*lambda_use(:, len_constx+len_constdx+ind_constx)];
            end
    end
end

J = A*x + b;

% check for length and width of A
heightX = length(x);
heightA = size(J_cost_combined, 1);

if heightA < heightX % the A matrix is 'wide'. apply regulariation
    J = J + (1e-9)*norm(x);
else % else square, or 'tall' matrix
    % don't do anything
end
end